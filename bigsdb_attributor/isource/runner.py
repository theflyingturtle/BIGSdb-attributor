# -*- coding: utf-8 -*-
import os
import subprocess
import sys
import tqdm

from bigsdb_attributor.isource.config import N, THINNING, ALPHA, \
    ISOURCE_RESULTS


class ISourceRuntimeError(RuntimeError):
    pass


def run(data, label, max_populations, executable=None, output_directory=None):
    """Run iSource with the given data and options.

    `data` should be a pandas dataframe in the correct format for iSource.

    Returns the path to the output file generated by iSource.

    """
    # Try to find iSource binary
    if executable is None:
        raise ISourceRuntimeError('Could not find iSource binary.')

    if not os.path.isdir(output_directory):
        os.mkdir(output_directory)

    data = os.path.abspath(data)

    def path(f=''):
        return os.path.join(output_directory, f)

    # Parse iSource input dataframe to extract various bits of data
    if not os.path.isfile(data):
        raise ISourceRuntimeError('Could not find file {}'.format(data))

    # Run iSource
    with open(path('isource_runtime.log'), mode='wb', buffering=0) as runtime, \
            tqdm.tqdm(total=N) as pbar:
        isource_p = subprocess.Popen(
            [
                os.path.expanduser(executable),
                data,
                ISOURCE_RESULTS,
                str(N),  # number of iterations
                str(THINNING),  # thinning,
                str(ALPHA),  # Dirichlet uniform prior
            ],
            stdout=subprocess.PIPE,
            stderr=sys.stderr,
            cwd=path(),
        )
        # This is effectively `.communicate()` but lets us inspect the lines, which is great for tqdm
        rc = isource_p.poll()
        pbar.update(1)
        while rc != 0:
            while True:
                byte = isource_p.stdout.read(1)
                if not byte:
                    break
                runtime.write(byte)
                if byte == b'\r':
                    pbar.update(0.5)  # There are two \rs per iteration
                    runtime.write(b'\n')  # so the log file is more readable
            rc = isource_p.poll()

        isource_p.communicate()

    return path('g_' + ISOURCE_RESULTS)
